DROP TYPE IF EXISTS state CASCADE; CREATE TYPE state AS ENUM('Start', 'Success', 'Failure'); CREATE TABLE IF NOT EXISTS Peers ( Nickname varchar(50) primary key not null, Birthday date); CREATE TABLE IF NOT EXISTS Tasks ( Title varchar(50) primary key not null, ParentTask varchar(50) default null, MaxXP int not null, foreign key (ParentTask) references Tasks (Title) ); CREATE TABLE IF NOT EXISTS Checks ( ID serial primary key, Peer varchar(50) not null, Task varchar(50) not null, Date date, foreign key (Peer) references Peers (Nickname), foreign key (Task) references Tasks (Title) ); CREATE TABLE IF NOT EXISTS P2P ( ID serial primary key, Check_ int not null, CheckingPeer varchar(50) not null, State state, Time time, foreign key (Check_) references Checks (ID), foreign key (CheckingPeer) references Peers (Nickname) ); CREATE TABLE IF NOT EXISTS Verter ( ID serial primary key, Check_ int not null, State state, Time time, foreign key (Check_) references Checks (ID) ); CREATE TABLE IF NOT EXISTS XP ( ID serial primary key, Check_ int not null, XPAmount int not null, foreign key (Check_) references Checks (ID) ); CREATE TABLE IF NOT EXISTS TransferredPoints ( ID serial primary key, CheckingPeer varchar(50) not null, CheckedPeer varchar(50) not null, PointsAmount int not null, foreign key (CheckingPeer) references Peers (Nickname), foreign key (CheckedPeer) references Peers (Nickname), check (CheckingPeer != CheckedPeer), unique (CheckedPeer, CheckingPeer) ); CREATE TABLE IF NOT EXISTS Friends ( ID serial primary key, Peer1 varchar(50) not null, Peer2 varchar(50) not null, foreign key (Peer1) references Peers (Nickname), foreign key (Peer2) references Peers (Nickname), check (Peer1 != Peer2) ); CREATE TABLE IF NOT EXISTS Recommendations ( ID serial primary key, Peer varchar(50) not null, RecommendedPeer varchar(50), foreign key (Peer) references Peers (Nickname), foreign key (RecommendedPeer) references Peers (Nickname), check (Peer != RecommendedPeer), unique (Peer, RecommendedPeer) ); CREATE TABLE IF NOT EXISTS TimeTracking ( ID serial primary key, Peer varchar(50), Date date, Time time, State int check (State in (1, 2)), foreign key (Peer) references Peers (Nickname) ); TRUNCATE TABLE xp CASCADE; TRUNCATE TABLE p2p CASCADE; TRUNCATE TABLE checks CASCADE; TRUNCATE TABLE friends CASCADE; TRUNCATE TABLE peers CASCADE; TRUNCATE TABLE recommendations CASCADE; TRUNCATE TABLE tasks CASCADE; TRUNCATE TABLE timetracking CASCADE; TRUNCATE TABLE transferredpoints CASCADE; TRUNCATE TABLE verter CASCADE; INSERT INTO peers (nickname, birthday) VALUES ('dhammer', '2002-01-26'), ('wloyd', '1999-09-09'), ('mcarb', '1998-08-08'), ('quas', '2010-03-09'), ('wex', '2007-11-11'), ('exort', '2013-07-09'), ('bajaj', '1990-02-25'); INSERT INTO tasks (title, parenttask, maxxp) VALUES ('s21_SimpleBashUtils', null, 250), ('s21_string+', 's21_SimpleBashUtils', 500), ('s21_math', 's21_SimpleBashUtils', 300), ('s21_decimal', 's21_SimpleBashUtils', 350), ('s21_matrix', 's21_decimal', 200), ('s21_SmartCalc_v1.0', 's21_matrix', 500), ('A_Maze', 's21_matrix', 300), ('A_SimpleNavigator', 'A_Maze', 400), ('A_Parallels', 'A_SimpleNavigator', 300); INSERT INTO friends (peer1, peer2) VALUES ('mcarb', 'wloyd'), ('quas', 'dhammer'), ('exort', 'quas'), ('wex', 'dhammer'), ('exort', 'wex'); INSERT INTO recommendations (peer, recommendedpeer) VALUES ('wex', 'exort'), ('dhammer', 'wloyd'), ('mcarb', 'wex'), ('wex', 'quas'), ('quas', 'mcarb'); INSERT INTO timetracking (peer, date, time, state) VALUES ('wex', '2022-08-24', '15:00', 1), ('wex', '2022-08-24', '17:15', 2), ('wloyd', '2022-07-12', '12:00', 1), ('wloyd', '2022-07-12', '18:25', 2), ('quas', '2022-07-07', '07:20', 1), ('quas', '2022-07-07', '12:00', 2), ('bajaj', '2022-09-04', '08:00', 1), ('quas', '2022-09-04', '10:00', 1), ('quas', '2022-09-04', '11:25', 2), ('exort', '2022-09-04', '09:00', 1), ('wex', '2022-09-04', '10:05', 1), ('wex', '2022-09-04', '10:45', 2), ('wex', '2022-09-04', '11:00', 1), ('wex', '2022-08-11', '09:40', 1), ('wex', '2022-08-11', '11:00', 2), ('wex', '2022-08-12', '10:00', 1), ('wex', '2022-08-12', '11:00', 2), ('wex', '2022-08-13', '10:20', 1), ('wex', '2022-09-13', '11:00', 2); INSERT INTO transferredpoints (checkingpeer, checkedpeer, pointsamount) VALUES ('quas', 'wex', 5), ('wloyd', 'mcarb', 3), ('exort', 'dhammer', 2), ('wex', 'quas', 3), ('mcarb', 'exort', 4); INSERT INTO checks (id, peer, task, date) VALUES (0, 'quas', 's21_SimpleBashUtils', '2022-08-11'), (1, 'exort', 's21_SimpleBashUtils', '2022-08-12'), (2, 'wex', 's21_SimpleBashUtils', '2022-08-12'), (3, 'dhammer', 's21_SimpleBashUtils', '2022-08-12'), (4, 'mcarb', 's21_SimpleBashUtils', '2022-08-12'), (5, 'bajaj', 's21_SimpleBashUtils', '2022-08-12'), (6, 'wloyd', 's21_SimpleBashUtils', '2022-08-12'), (7, 'exort', 's21_decimal', '2022-08-20'), (8, 'exort', 's21_matrix', '2022-08-29'), (9, 'exort', 'A_Maze', '2022-09-05'), (10, 'exort', 'A_SimpleNavigator', '2022-09-15'), (11, 'exort', 's21_math', '2022-09-18'), (12, 'exort', 's21_string+', '2022-09-20'), (13, 'exort', 's21_SmartCalc_v1.0', '2022-09-22'); INSERT INTO p2p (check_, checkingpeer, state, time) VALUES (0, 'exort', 'Start', '9:00'), (0, 'exort', 'Success', '9:20'), (1, 'mcarb', 'Start', '10:00'), (1, 'mcarb', 'Success', '10:15'), (2, 'wloyd', 'Start', '13:20'), (2, 'wloyd', 'Success', '13:45'), (3, 'quas', 'Start', '13:45'), (3, 'quas', 'Success', '14:25'), (4, 'dhammer', 'Start', '15:00'), (4, 'dhammer', 'Success', '15:35'), (5, 'wex', 'Start', '15:05'), (5, 'wex', 'Failure', '15:20'), (6, 'exort', 'Start', '15:08'), (6, 'exort', 'Success', '15:25'), (7, 'wex', 'Start', '17:00'), (7, 'wex', 'Success', '17:25'), (8, 'wex', 'Start', '10:00'), (8, 'wex', 'Success', '10:20'), (9, 'mcarb', 'Start', '15:00'), (9, 'mcarb', 'Success', '15:25'), (10, 'dhammer', 'Start', '15:00'), (10, 'dhammer', 'Success', '15:25'), (11, 'wex', 'Start', '10:00'), (11, 'wex', 'Success', '10:20'), (12, 'mcarb', 'Start', '15:00'), (12, 'mcarb', 'Success', '15:25'), (13, 'dhammer', 'Start', '15:00'), (13, 'dhammer', 'Success', '15:25'); INSERT INTO verter (check_, state, time) VALUES (0, 'Start', '9:25'), (0, 'Success', '9:28'), (1, 'Start', '10:00'), (1, 'Success', '11:00'), (2, 'Start', '13:55'), (2, 'Success', '14:02'), (3, 'Start', '14:45'), (3, 'Success', '14:51'), (4, 'Start', '15:45'), (4, 'Failure', '15:59'), (6, 'Start', '16:00'), (6, 'Success', '16:10'), (7, 'Start', '17:30'), (7, 'Success', '17:41'), (8, 'Start', '10:45'), (8, 'Failure', '10:51'), (11, 'Start', '10:45'), (11, 'Failure', '10:51'), (12, 'Start', '15:30'), (12, 'Success', '15:45'), (13, 'Start', '15:38'), (13, 'Success', '15:51'); INSERT INTO xp (check_, xpamount) SELECT check_, (maxxp * (1 - 0.5 * random()))::int AS xpamount FROM (SELECT p.check_, c.task, t.maxxp, v.state FROM p2p p JOIN checks c ON p.check_ = c.id JOIN tasks t ON c.task = t.title LEFT OUTER JOIN verter v ON v.check_ = p.check_ where p.state = 'Success' AND ( v.state = 'Success' OR v.state IS NULL )) AS A; drop procedure if exists export_table(varchar, varchar, varchar); create or replace procedure export_table(file_name varchar(255), table_name varchar(255), delimiter varchar(4)) language plpgsql as $$ declare dir varchar(255) := (select setting as directory from pg_settings where name = 'data_directory') || '/' || file_name; begin EXECUTE format('copy %s to %L with csv delimiter %L header', quote_ident(table_name), dir, delimiter); end $$; drop procedure if exists import_table(varchar, varchar, varchar); create or replace procedure import_table(file_name varchar(255), table_name varchar(255), delimiter varchar(4)) language plpgsql as $$ declare dir varchar(255) := (select setting as directory from pg_settings where name = 'data_directory') || '/' || file_name; begin EXECUTE format('copy %s from %L with csv delimiter %L header', quote_ident(table_name), dir, delimiter); end $$; create or replace procedure import_checks(delimiter varchar(255)) language plpgsql as $$ begin call import_table('checks.csv', 'checks', delimiter); end $$; create or replace procedure import_friends(delimiter varchar(255)) language plpgsql as $$ begin call import_table('friends.csv', 'friends', delimiter); end $$; create or replace procedure import_p2p(delimiter varchar(255)) language plpgsql as $$ begin call import_table('p2p.csv', 'p2p', delimiter); end $$; create or replace procedure import_peers(delimiter varchar(255)) language plpgsql as $$ begin call import_table('peers.csv', 'peers', delimiter); end $$; create or replace procedure import_recommendations(delimiter varchar(255)) language plpgsql as $$ begin call import_table('recommendations.csv', 'recommendations', delimiter); end $$; create or replace procedure import_tasks(delimiter varchar(255)) language plpgsql as $$ begin call import_table('tasks.csv', 'tasks', delimiter); end $$; create or replace procedure import_timetracking(delimiter varchar(255)) language plpgsql as $$ begin call import_table('timetracking.csv', 'timetracking', delimiter); end $$; create or replace procedure import_tranferredpoints(delimiter varchar(255)) language plpgsql as $$ begin call import_table('tranferredpoints.csv', 'tranferredpoints', delimiter); end $$; create or replace procedure import_verter(delimiter varchar(255)) language plpgsql as $$ begin call import_table('verter.csv', 'verter', delimiter); end $$; create or replace procedure import_xp(delimiter varchar(255)) language plpgsql as $$ begin call import_table('xp.csv', 'xp', delimiter); end $$; create or replace procedure export_checks(delimiter varchar(255)) language plpgsql as $$ begin call export_table('checks.csv', 'checks', delimiter); end $$; create or replace procedure export_friends(delimiter varchar(255)) language plpgsql as $$ begin call export_table('friends.csv', 'friends', delimiter); end $$; create or replace procedure export_p2p(delimiter varchar(255)) language plpgsql as $$ begin call export_table('p2p.csv', 'p2p', delimiter); end $$; create or replace procedure export_peers(delimiter varchar(255)) language plpgsql as $$ begin call export_table('peers.csv', 'peers', delimiter); end $$; create or replace procedure export_recommendations(delimiter varchar(255)) language plpgsql as $$ begin call export_table('recommendations.csv', 'recommendations', delimiter); end $$; create or replace procedure export_tasks(delimiter varchar(255)) language plpgsql as $$ begin call export_table('tasks.csv', 'tasks', delimiter); end $$; create or replace procedure export_timetracking(delimiter varchar(255)) language plpgsql as $$ begin call export_table('timetracking.csv', 'timetracking', delimiter); end $$; create or replace procedure export_tranferredpoints(delimiter varchar(255)) language plpgsql as $$ begin call export_table('tranferredpoints.csv', 'tranferredpoints', delimiter); end $$; create or replace procedure export_verter(delimiter varchar(255)) language plpgsql as $$ begin call export_table('verter.csv', 'verter', delimiter); end $$; create or replace procedure export_xp(delimiter varchar(255)) language plpgsql as $$ begin call export_table('xp.csv', 'xp', delimiter); end $$; DROP PROCEDURE IF EXISTS InsertP2PCheck; CREATE OR REPLACE PROCEDURE InsertP2PCheck( _CheckedPeer peers.nickname % TYPE, _CheckingPeer peers.nickname % TYPE, _task tasks.title % TYPE, _state state, _time time ) LANGUAGE plpgsql AS $$ DECLARE _check_id int; BEGIN IF _state = 'Start' THEN INSERT INTO Checks (Peer, Task, Date) VALUES (_CheckedPeer, _task, (SELECT CURRENT_DATE)); _check_id = (SELECT last_value FROM checks_id_seq); ELSE _check_id = (WITH s AS (SELECT * FROM p2p WHERE (state = 'Start')), e AS (SELECT * FROM p2p WHERE (state != 'Start')), f AS (SELECT s.check_, s.checkingpeer, s.state AS begin_state, s.time AS start_time, e.state AS end_state, e.time AS end_time FROM s FULL JOIN e USING (check_, checkingpeer) WHERE e.state IS NULL ORDER BY s.check_ DESC) SELECT check_ FROM f WHERE (checkingpeer = _CheckingPeer) ORDER BY check_ DESC, start_time DESC LIMIT 1); END IF; INSERT INTO P2P (check_, checkingpeer, state, time) VALUES (_check_id, _CheckingPeer, _state, _time); END; $$; DROP PROCEDURE IF EXISTS InsertVerterCheck; CREATE OR REPLACE PROCEDURE InsertVerterCheck( _CheckedPeer peers.nickname % TYPE, _task tasks.title % TYPE, _state state, _time time ) LANGUAGE plpgsql AS $$ DECLARE _check_id int; BEGIN _check_id = (SELECT checks.id FROM p2p JOIN checks ON p2p.check_ = checks.id WHERE state = 'Success' AND checks.task = _task ORDER BY time DESC, checks.id DESC LIMIT 1); INSERT INTO verter (check_, state, time) VALUES (_check_id, _state, _time); END; $$; DROP TRIGGER IF EXISTS trg_P2P ON p2p; DROP FUNCTION IF EXISTS fnc_trg_P2P; CREATE OR REPLACE FUNCTION fnc_trg_P2P() RETURNS trigger AS $$ DECLARE _checkedpeer peers.nickname % TYPE; current_points int; BEGIN if (NEW.state = 'Start') THEN _checkedpeer = (SELECT peer FROM checks WHERE id = NEW.check_); current_points = (SELECT pointsamount FROM transferredpoints WHERE checkingpeer = NEW.checkingpeer AND checkedpeer = _checkedpeer); IF current_points IS NULL THEN INSERT INTO TransferredPoints(checkingpeer, checkedpeer, pointsamount) VALUES (NEW.checkingpeer, _checkedpeer, 1); ELSE UPDATE TransferredPoints SET pointsamount = current_points + 1 WHERE checkingpeer = NEW.checkingpeer AND checkedpeer = _checkedpeer; END IF; end if; RETURN NEW; END; $$ LANGUAGE 'plpgsql'; CREATE OR REPLACE TRIGGER trg_P2P AFTER INSERT ON P2P FOR EACH ROW EXECUTE PROCEDURE fnc_trg_P2P(); DROP TRIGGER IF EXISTS trg_XP ON xp; DROP FUNCTION IF EXISTS fnc_trg_XP; CREATE OR REPLACE FUNCTION fnc_trg_XP() RETURNS trigger AS $$ DECLARE maxXpAmount xp.xpamount % TYPE; checkTitle tasks.title % TYPE; checkStatus boolean; BEGIN checkTitle = (SELECT task FROM checks WHERE checks.id = NEW.check_); maxXpAmount = (SELECT maxxp FROM tasks WHERE title = checkTitle); IF ( EXISTS( SELECT state FROM p2p WHERE check_ = NEW.check_ AND state = 'Success' ) AND ( EXISTS( SELECT state FROM verter WHERE check_ = NEW.check_ AND state = 'Success' ) OR NOT EXISTS( SELECT state FROM verter WHERE check_ = NEW.check_ ) ) ) THEN checkStatus = 'true'; ELSE checkStatus = 'false'; END IF; IF NEW.xpamount > maxXpAmount THEN RETURN NULL; ELSIF checkStatus = 'false' THEN RETURN NULL; END IF; RETURN NEW; END; $$ LANGUAGE 'plpgsql'; CREATE OR REPLACE TRIGGER trg_XP BEFORE INSERT ON xp FOR EACH ROW EXECUTE PROCEDURE fnc_trg_XP(); DROP FUNCTION IF EXISTS TransferredPoints; CREATE OR REPLACE FUNCTION TransferredPoints() RETURNS TABLE ( peer1 varchar, peer2 varchar, PointsAmount int ) AS $$ BEGIN RETURN QUERY EXECUTE 'SELECT Peer1, Peer2, COALESCE(t1.PointsAmount, 0) - COALESCE(t2.PointsAmount, 0) AS PointsAmount FROM (SELECT DISTINCT CASE WHEN CheckingPeer > CheckedPeer THEN CheckingPeer ELSE CheckedPeer END AS Peer1, CASE WHEN CheckingPeer <= CheckedPeer THEN CheckingPeer ELSE CheckedPeer END AS Peer2 FROM TransferredPoints)p LEFT JOIN TransferredPoints t1 ON p.Peer1 = t1.CheckingPeer AND p.Peer2 = t1.CheckedPeer LEFT JOIN TransferredPoints t2 ON p.Peer1 = t2.CheckedPeer AND p.Peer2 = t2.CheckingPeer ORDER BY Peer1, Peer2 '; END; $$ LANGUAGE plpgsql; DROP FUNCTION IF EXISTS CheckedPeersWithXP; CREATE OR REPLACE FUNCTION CheckedPeersWithXP() RETURNS TABLE ( Peer varchar(255), Task varchar(255), XP int ) AS $$ select c.peer, c.task, xp.xpamount from p2p p left join checks c on p.check_ = c.id left join verter v on v.check_ = c.id left join xp on c.id = xp.check_ left join tasks t on t.title = c.task where p.state = 'Success' AND ( v.state = 'Success' OR v.state IS NULL ) AND xp.xpamount * 100 / t.maxxp >= 80; $$ LANGUAGE SQL; DROP FUNCTION IF EXISTS PeersInCampus; CREATE OR REPLACE FUNCTION PeersInCampus(date_ date) RETURNS TABLE ( Peer varchar(30) ) AS $$ WITH count_ AS (SELECT t1.peer, t1.date, t1.state, COUNT(t1.peer) AS cv FROM timetracking t1 GROUP BY t1.date, t1.peer, t1.state) SELECT DISTINCT t3.peer FROM (SELECT t.peer, t.date FROM timetracking t WHERE (SELECT cv FROM count_ c WHERE t.peer = c.peer AND t.date = c.date AND c.state = 1) = 1 AND ( (SELECT cv FROM count_ c WHERE t.peer = c.peer AND t.date = c.date AND c.state = 2) = 1 OR NOT EXISTS( SELECT cv FROM count_ c WHERE t.peer = c.peer AND t.date = c.date AND c.state = 2 ) )) as t3 WHERE date = date_; $$ LANGUAGE SQL; DROP PROCEDURE IF EXISTS CheckSuccessRatio; CREATE OR REPLACE PROCEDURE CheckSuccessRatio(result_data refcursor) LANGUAGE plpgsql AS $$ BEGIN OPEN result_data FOR WITH all_count as (SELECT count(*) / 2 as count_ FROM p2p), success_count as (SELECT count(*) as count_ FROM p2p WHERE state = 'Success') SELECT success_count.count_ * 100 / all_count.count_ as SuccessfulChecks, (all_count.count_ - success_count.count_) * 100 / all_count.count_ as UnsuccessfulChecks FROM all_count, success_count; END; $$; CREATE OR REPLACE PROCEDURE PointsChange(result_data refcursor) AS $$ BEGIN OPEN result_data FOR SELECT Peer, SUM(PointsChange) AS PointsChange FROM (SELECT CheckingPeer AS Peer, PointsAmount AS PointsChange FROM TransferredPoints UNION SELECT CheckedPeer, - PointsAmount FROM TransferredPoints) chages GROUP BY Peer ORDER BY PointsChange; END; $$ LANGUAGE plpgsql; CREATE OR REPLACE PROCEDURE PointsChange_v2(result_data refcursor) AS $$ BEGIN OPEN result_data FOR SELECT Peer, SUM(pointsamount) AS PointsChange FROM (SELECT peer1 AS peer, pointsamount FROM transferredpoints() UNION SELECT peer2, - pointsamount FROM transferredpoints()) tp GROUP BY Peer ORDER BY PointsChange; END; $$ LANGUAGE plpgsql; DROP PROCEDURE IF EXISTS MostFrequentTaskDaily; CREATE OR REPLACE PROCEDURE MostFrequentTaskDaily(result_data refcursor) LANGUAGE plpgsql AS $$ DECLARE _check_id int; BEGIN OPEN result_data FOR WITH A AS (SELECT date, checks.task, COUNT(id) AS countId FROM checks GROUP BY checks.task, date) SELECT date AS day, B.task FROM (SELECT A.task, A.date, rank() OVER ( PARTITION BY A.date ORDER BY countId DESC ) AS rank FROM A) AS B WHERE rank = 1 ORDER BY day; END; $$; DROP PROCEDURE IF EXISTS DurationLatestP2PCheck; CREATE OR REPLACE PROCEDURE DurationLatestP2PCheck() LANGUAGE plpgsql AS $$ DECLARE _check_id int; time_start time; time_end time; duration interval; BEGIN _check_id = (WITH A AS (SELECT date + time AS datetime, peer, checkingpeer, state, check_ FROM p2p LEFT JOIN checks ON p2p.check_ = checks.id) SELECT check_ FROM A WHERE datetime = (SELECT max(datetime) FROM A) ORDER BY check_ LIMIT 1); time_start = (SELECT time FROM p2p WHERE check_ = _check_id AND state = 'Start'); time_end = (SELECT time FROM p2p WHERE check_ = _check_id AND state != 'Start'); SET intervalstyle = postgres_verbose; duration = time_end - time_start; RAISE NOTICE '%', duration; END; $$; DROP PROCEDURE IF EXISTS CompleteBlock; CREATE OR REPLACE PROCEDURE CompleteBlock(result_data refcursor, block varchar) LANGUAGE plpgsql AS $$ DECLARE count integer; BEGIN count = (SELECT COUNT(tasks.title) FROM tasks WHERE tasks.title ~ CONCAT('^', block)); OPEN result_data FOR WITH A AS (SELECT p2p.check_, p2p.state FROM p2p WHERE p2p.state = 'Success'), B AS (SELECT verter.check_, verter.state FROM verter WHERE verter.state = 'Success'), C AS (SELECT COUNT(id) AS count_success, MAX(date) AS day, peer FROM checks WHERE task ~ CONCAT('^', block) AND checks.id IN (SELECT check_ FROM A) AND checks.id IN (SELECT check_ FROM A) GROUP BY peer) SELECT peer, day FROM C WHERE count_success = count; END; $$; CREATE OR REPLACE PROCEDURE FindPeerForCheck(result_data refcursor) AS $$ BEGIN OPEN result_data FOR WITH recomend_count AS (SELECT f.peer, COUNT(friend) AS recommendations_count, RecommendedPeer FROM (SELECT Peer1 AS peer, Peer2 AS friend FROM friends UNION SELECT Peer2, Peer1 FROM friends) f JOIN recommendations ON f.friend = recommendations.peer AND f.peer <> recommendations.recommendedpeer GROUP BY f.peer, recommendedpeer) SELECT r.peer as Peer, recomend_count.RecommendedPeer FROM (SELECT peer, MAX(recommendations_count) AS max_recomend_count FROM recomend_count GROUP BY peer) r JOIN recomend_count ON r.peer = recomend_count.peer AND r.max_recomend_count = recomend_count.recommendations_count ORDER BY Peer, RecommendedPeer; END; $$ LANGUAGE plpgsql; DROP PROCEDURE IF EXISTS PeersByGroups; CREATE OR REPLACE PROCEDURE PeersByGroups(result_data refcursor) LANGUAGE plpgsql AS $$ BEGIN OPEN result_data FOR with count_peers as (select count(*) as count_ from peers), count_peers_C as (select count(*) as count_ from (select distinct on (peer) * from checks where task ~ '^s21') as temp), count_peers_CPP as (select count(*) as count_ from (select distinct on (peer) * from checks where task ~ '^A') as temp), count_peers_none as (select count(*) as count_ from peers left join (select * from checks where task ~ '^(A|s21)') as temp on peers.nickname = temp.peer where id is null), count_peers_all as (select count(*) as count_ from (select distinct on (peer) peer from checks where task ~ '^s21' intersect select distinct on (peer) peer from checks where task ~ '^A') as temp) select (count_peers_C.count_ * 100 / count_peers.count_) as StartedBlock1, ( count_peers_CPP.count_ * 100 / count_peers.count_ ) as StartedBlock2, ( count_peers_all.count_ * 100 / count_peers.count_ ) as StartedBothBlocks, ( count_peers_none.count_ * 100 / count_peers.count_ ) as DidntStartAnyBlock from count_peers_none, count_peers_C, count_peers, count_peers_all, count_peers_CPP; END; $$; DROP PROCEDURE IF EXISTS PeersWithGreatestNumberFriends; CREATE OR REPLACE PROCEDURE PeersWithGreatestNumberFriends(result_data refcursor, N int) AS $$ BEGIN OPEN result_data FOR SELECT Peer, COUNT(friend) AS FriendsCount FROM (SELECT Peer1 AS peer, Peer2 AS friend FROM friends UNION SELECT Peer2, Peer1 FROM friends) f GROUP BY Peer ORDER BY FriendsCount DESC LIMIT N; END; $$ LANGUAGE plpgsql; DROP FUNCTION IF EXISTS FPeersWithBDayCheck; CREATE OR REPLACE FUNCTION FPeersWithBDayCheck() RETURNS TABLE ( SuccessfulChecks int, UnsuccessfulChecks int ) AS $$ with temp_table as (select state from p2p left join checks on p2p.check_ = checks.id left join peers on checks.peer = peers.nickname where extract( day from checks.date ) = extract( day from peers.birthday ) and extract( month from checks.date ) = extract( month from peers.birthday )), all_count as (select count(*) as count_ from temp_table where state = 'Start'), success_count as (select count(*) as count_ from temp_table where state = 'Success'), failure_count as (select count(*) as count_ from temp_table where state = 'Failure') select (success_count.count_ * 100 / all_count.count_), (failure_count.count_ * 100 / all_count.count_) from success_count, failure_count, all_count; $$ LANGUAGE SQL; DROP PROCEDURE IF EXISTS PeersWithBDayCheck; CREATE OR REPLACE PROCEDURE PeersWithBDayCheck(result_data refcursor) LANGUAGE plpgsql AS $$ BEGIN OPEN result_data FOR with temp_table as (select state from p2p left join checks on p2p.check_ = checks.id left join peers on checks.peer = peers.nickname where extract( day from checks.date ) = extract( day from peers.birthday ) and extract( month from checks.date ) = extract( month from peers.birthday )), all_count as (select count(*) as count_ from temp_table where state = 'Start'), success_count as (select count(*) as count_ from temp_table where state = 'Success'), failure_count as (select count(*) as count_ from temp_table where state = 'Failure') select ( success_count.count_ * 100 / CASE WHEN all_count.count_ = 0 THEN 1 ELSE all_count.count_ END ) AS SuccessfulChecks, ( failure_count.count_ * 100 / CASE WHEN all_count.count_ = 0 THEN 1 ELSE all_count.count_ END ) AS UnsuccessfulChecks from success_count, failure_count, all_count; END; $$; DROP PROCEDURE IF EXISTS TotalXP; CREATE OR REPLACE PROCEDURE TotalXP(result_data refcursor) AS $$ BEGIN OPEN result_data FOR SELECT peer AS Peer, SUM(XPAmount) AS XP FROM (SELECT peer, task, MAX(XPAmount) AS XPAmount FROM xp JOIN checks ON xp.check_ = checks.id GROUP BY peer, task) xp GROUP BY peer ORDER BY XP; END; $$ LANGUAGE plpgsql; DROP PROCEDURE IF EXISTS GivenAndNotGivenTasks; CREATE OR REPLACE PROCEDURE GivenAndNotGivenTasks( result_data refcursor, task1 varchar, task2 varchar, task3 varchar ) AS $$ BEGIN OPEN result_data FOR SELECT Peer FROM (SELECT Peer, SUM( CASE WHEN Task = task1 THEN 1 ELSE 0 END ) AS is_task1_do, SUM( CASE WHEN Task = task2 THEN 1 ELSE 0 END ) AS is_task2_do, SUM( CASE WHEN Task = task3 THEN 1 ELSE 0 END ) AS is_task3_do FROM (SELECT DISTINCT Peer, Task FROM xp JOIN checks ON xp.check_ = checks.id) ch GROUP BY Peer) is_do WHERE is_task1_do = 1 and is_task2_do = 1 and is_task3_do = 0; END; $$ LANGUAGE plpgsql; DROP PROCEDURE IF EXISTS CountOfPreviousTasks; CREATE OR REPLACE PROCEDURE CountOfPreviousTasks(result_data refcursor) LANGUAGE plpgsql AS $$ DECLARE count_tasks integer; BEGIN OPEN result_data FOR WITH RECURSIVE recursiveQuery(title, parenttask, n) AS (SELECT tasks.title, tasks.parenttask, 0 FROM tasks UNION SELECT T.title, T.parenttask, n + 1 FROM tasks T INNER JOIN recursiveQuery REC ON REC.title = T.parenttask) SELECT title AS Task, MAX(n) AS PrevCount FROM recursiveQuery GROUP BY title ORDER BY PrevCount ASC; END; $$; DROP PROCEDURE IF EXISTS FindLuckyDaysForChecks; CREATE OR REPLACE PROCEDURE FindLuckyDaysForChecks(result_data refcursor, N int) AS $$ BEGIN OPEN result_data FOR WITH data AS (SELECT date, time, status_check, LEAD(status_check) OVER ( ORDER BY date, time ) AS next_status_check FROM (SELECT checks.date, CASE WHEN 100 * xp.XPAmount / tasks.MaxXP >= 80 THEN true ELSE false END AS status_check, p2p.time FROM checks JOIN tasks ON checks.task = tasks.title JOIN xp ON checks.id = xp.check_ JOIN p2p ON checks.id = p2p.check_ AND p2p.state in ('Success', 'Failure')) ch), data_prev_checks AS (SELECT t1.date, t1.time, t1.status_check, t1.next_status_check, COUNT(t2.date) FROM data t1 JOIN data t2 on t1.date = t2.date AND t1.time <= t2.time AND t1.status_check = t2.next_status_check GROUP BY t1.date, t1.time, t1.status_check, t1.next_status_check) SELECT date FROM (SELECT date, MAX(success_count) AS max_success_count FROM (SELECT date, count as success_count FROM data_prev_checks WHERE status_check) success_checks GROUP BY date) m WHERE max_success_count >= N; END; $$ LANGUAGE plpgsql; DROP PROCEDURE IF EXISTS GetPeerWithMaxTasks; CREATE OR REPLACE PROCEDURE GetPeerWithMaxTasks(result_data refcursor) LANGUAGE plpgsql AS $$ BEGIN OPEN result_data FOR WITH t AS (SELECT c.id, c.task, c.date, c.peer, CASE WHEN pe.state = 'Success' AND ( v.state = 'Success' OR v.state IS NULL ) AND xpamount * 100 / maxxp >= 80 THEN 1 ELSE 0 END AS successful, pe.state AS p2p_state, v.state AS verter_state, ps.time start_time, xpamount * 100 / maxxp AS percentage FROM checks c LEFT JOIN (SELECT check_, time, state FROM p2p WHERE state = 'Start') ps ON ps.check_ = c.id JOIN (SELECT check_, time, state FROM p2p WHERE state != 'Start') pe ON pe.check_ = c.id LEFT JOIN (SELECT check_, time, state FROM verter WHERE state != 'Start') v ON v.check_ = c.id LEFT JOIN xp ON c.id = xp.check_ LEFT JOIN tasks t ON c.task = t.title ORDER BY date, start_time) SELECT DISTINCT peer, sum(successful) OVER (PARTITION BY peer) AS XP FROM t ORDER BY XP DESC LIMIT 1; END; $$; DROP PROCEDURE IF EXISTS GetPeerWithMaxXp; CREATE OR REPLACE PROCEDURE GetPeerWithMaxXp(result_data refcursor) LANGUAGE plpgsql AS $$ BEGIN OPEN result_data FOR SELECT peer, sum(xpamount) FROM xp JOIN checks c ON xp.check_ = c.id GROUP BY peer; END; $$; DROP PROCEDURE IF EXISTS GetPeerMaxTimeSpent; CREATE OR REPLACE PROCEDURE GetPeerMaxTimeSpent(result_data refcursor) LANGUAGE plpgsql AS $$ BEGIN OPEN result_data FOR WITH t AS (SELECT *, date + time AS datetime FROM timetracking), cs AS (SELECT peer, state AS current_state FROM t JOIN(SELECT peer, MAX(datetime) AS datetime FROM t GROUP BY peer) m USING (peer, datetime)) SELECT DISTINCT peer FROM (SELECT DISTINCT peer, date, current_state, ( CASE WHEN current_state = 1 THEN to_char( COALESCE( date_trunc('second', LOCALTIME) + sum(time) FILTER ( WHERE state = 2 ) OVER (PARTITION BY peer, date), date_trunc('second', LOCALTIME) ) - sum(time) FILTER ( WHERE state = 1 ) OVER (PARTITION BY peer, date), 'HH24:MI:SS' ) ELSE to_char( sum(time) FILTER ( WHERE state = 2 ) OVER (PARTITION BY peer, date) - sum(time) FILTER ( WHERE state = 1 ) OVER (PARTITION BY peer, date), 'HH24:MI:SS' ) END ) time_spent FROM t JOIN cs USING (peer) WHERE date = CURRENT_DATE ORDER BY time_spent DESC LIMIT 1) data; END; $$; DROP PROCEDURE IF EXISTS GetPeerMaxTimeSpent; CREATE OR REPLACE PROCEDURE GetPeerMaxTimeSpent(result_data refcursor, TM time, N int) LANGUAGE plpgsql AS $$ BEGIN OPEN result_data FOR WITH t AS (SELECT DISTINCT peer, date, MIN(time) OVER (PARTITION BY peer, date) AS arrival_time FROM timetracking ORDER BY arrival_time) SELECT t1.peer, count(t1.peer) AS count FROM timetracking t1 JOIN t t2 ON t1.time = t2.arrival_time AND t1.date = t2.date and t1.peer = t2.peer WHERE arrival_time < TM AND t1.state = 1 GROUP BY t1.peer HAVING count(t1.peer) > N; END; $$; DROP PROCEDURE IF EXISTS GetPeersComingOutMoreNTimes; CREATE OR REPLACE PROCEDURE GetPeersComingOutMoreNTimes( result_data refcursor, N int, M int ) LANGUAGE plpgsql AS $$ BEGIN OPEN result_data FOR select timetracking.peer from timetracking where timetracking.state = 2 and current_date - timetracking.date <= N group by peer HAVING count(*) > M; END; $$; DROP PROCEDURE IF EXISTS PeerLastOut; CREATE OR REPLACE PROCEDURE PeerLastOut(result_data refcursor) LANGUAGE plpgsql AS $$ BEGIN OPEN result_data FOR select peer from timetracking where date = current_date and state = '1' order by time desc limit 1; END; $$; DROP PROCEDURE IF EXISTS PeersLeftNMinutes; CREATE OR REPLACE PROCEDURE PeersLeftNMinutes( result_data refcursor, N int ) LANGUAGE plpgsql AS $$ BEGIN OPEN result_data FOR with t1 as (select * from timetracking where state = '1' and timetracking.date = current_date - 1 order by peer, time), t2 as (select * from timetracking where state = '2' and timetracking.date = current_date - 1 order by peer, time) select distinct * from (select t1.peer from t1 join t2 on t1.peer = t2.peer and t1.id > t2.id and t1.time - t2.time > concat(N, 'minutes')::interval) as temp; END; $$; DROP PROCEDURE IF EXISTS EarlyEntries; CREATE OR REPLACE PROCEDURE EarlyEntries(result_data refcursor) LANGUAGE plpgsql AS $$ BEGIN OPEN result_data FOR with gs as (select generate_series(1, 12) as month_), all_count as (select date_part('month', timetracking.date) as month_, count(*) as count_ from timetracking left join peers on timetracking.peer = peers.nickname where timetracking.state = '1' and date_part('month', peers.birthday) = date_part('month', timetracking.date) group by date, birthday), early_count as (select date_part('month', timetracking.date) as month_, count(*) as count_ from timetracking left join peers on timetracking.peer = peers.nickname where timetracking.state = '1' and date_part('month', peers.birthday) = date_part('month', timetracking.date) and timetracking.time < '12:00' group by date, birthday) select to_char(to_timestamp(temp.month_::text, 'MM'), 'Mon') as month_, case when temp.count1 = 0 then null else temp.count2 * 100 / temp.count1 end from (select gs.month_, case when all_count.count_ is null then 0 else all_count.count_ end as count1, case when early_count.count_ is null then 0 else early_count.count_ end as count2 from gs left join all_count on all_count.month_ = gs.month_ left join early_count on early_count.month_ = gs.month_) as temp; END; $$; COMMENT ON PROCEDURE InsertP2PCheck IS 'Добавление P2P проверки. '; COMMENT ON PROCEDURE InsertVerterCheck IS 'Добавление проверки Verter-ом'; COMMENT ON FUNCTION TransferredPoints IS 'Возвращающает таблицу TransferredPoints в более человекочитаемом виде'; COMMENT ON FUNCTION CheckedPeersWithXP IS 'Возвращает таблицу вида: ник пользователя, название проверенного задания, кол-во полученного XP'; COMMENT ON FUNCTION PeersInCampus IS 'Определяет пиров, которые не выходили из кампуса в течение всего дня'; COMMENT ON PROCEDURE CheckSuccessRatio IS 'Определяет процент успешных и неуспешных проверок за всё время'; COMMENT ON PROCEDURE PointsChange IS 'Определяет изменение в количестве пир поинтов каждого пира по таблице TransferredPoints'; COMMENT ON PROCEDURE PointsChange_v2 IS 'Определяет изменение в количестве пир поинтов каждого пира по таблице, возвращаемой первой функцией TransferredPoints'; COMMENT ON PROCEDURE MostFrequentTaskDaily IS 'Определяет самое часто проверяемое задание за каждый день'; COMMENT ON PROCEDURE DurationLatestP2PCheck IS 'Определяет длительность последней P2P проверки'; COMMENT ON PROCEDURE CompleteBlock IS 'Определяет всех пиров, выполнивших весь заданный блок задач и дату завершения последнего задания'; COMMENT ON PROCEDURE FindPeerForCheck IS 'Определяет, к какому пиру стоит идти на проверку каждому обучающемуся'; COMMENT ON PROCEDURE PeersByGroups IS 'Определяет процент пиров, которые: Приступили к блоку 1; Приступили к блоку 2; Приступили к обоим; Не приступили ни к одному'; COMMENT ON PROCEDURE PeersWithGreatestNumberFriends IS 'Определяет N пиров с наибольшим числом друзей'; COMMENT ON FUNCTION FPeersWithBDayCheck IS 'Определяет процент пиров, которые когда-либо успешно проходили проверку в свой день рождения'; COMMENT ON PROCEDURE PeersWithBDayCheck IS 'Определяет кол-во XP, полученное в сумме каждым пиром'; COMMENT ON PROCEDURE TotalXP IS 'Определяет всех пиров, которые сдали заданные задания 1 и 2, но не сдали задание 3'; COMMENT ON PROCEDURE GivenAndNotGivenTasks IS 'Определяет для каждой задачи кол-во предшествующих ей задач'; COMMENT ON PROCEDURE CountOfPreviousTasks IS 'Определяет "удачные" для проверок дни. День считается "удачным", если в нем есть хотя бы N идущих подряд успешных проверки'; COMMENT ON PROCEDURE FindLuckyDaysForChecks IS 'Определяет пира с наибольшим числом выполненных заданий'; COMMENT ON PROCEDURE GetPeerWithMaxTasks IS 'Определяет пира с наибольшим количеством XP'; COMMENT ON PROCEDURE GetPeerWithMaxXp IS 'Определяет пира, который провел сегодня в кампусе больше всего времени'; COMMENT ON PROCEDURE GetPeerMaxTimeSpent IS 'Определяет пиров, приходивших раньше заданного времени не менее N раз за всё время'; COMMENT ON PROCEDURE GetPeersComingOutMoreNTimes IS 'Определяет пиров, выходивших за последние N дней из кампуса больше M раз'; COMMENT ON PROCEDURE PeerLastOut IS 'Определяет пира, который пришел сегодня последним'; COMMENT ON PROCEDURE PeersLeftNMinutes IS 'Определяет пиров, которые выходили вчера из кампуса больше чем на N минут'; COMMENT ON PROCEDURE EarlyEntries IS 'Определяет для каждого месяца процент ранних входов'; 